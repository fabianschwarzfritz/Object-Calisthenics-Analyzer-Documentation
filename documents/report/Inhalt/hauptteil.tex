\chapter{Introduction}
\label{Introduction}
The Object Calisthenics are nine programming rules helping to write good object oriented code.

The paper capter "The Object Calisthenics" describes the purpose, the outcome and the rules. It was released in 2008 in the paper "The thoughtworks anthology. Essays on Software Technology and Innovation"\cite[p. 70-79]{oc2008}. The whole paper consists of thirteen chapters discussing various topics and ideas on how to improve software development. On of the paper's chapter describes the rules of the Object Calisthenics and their purpose and outcome, shortly.

All essays in the paper are written by developers working at the company "Thoughtworks inc". ThoughtWorks is well known for creating, designing and supporting high quality software. The company is to be said to be one of the most future oriented company in terms of technology and software principals. They describe themselves as "[\dots]a software company and community of passionate inidividuals whose purpose is to revolutionize software design, creation and delivery, while advocating for positive social change[\dots]"\cite{twWeb}

\section{Exercizing Better Object Oriented Programming Skills: a Concept by Jeff Bay}
The Object Calisthenics are an exercise to improve the quality of Object Oriented code. Good Object Oriented Code is hard to learn when coming from procedural code. Many developers think in Object Oriented code – but do they really write good Object Oriented Software? That is the question that Jeff Bay poses in his essay. 
Usually the developer doesn't use these rules in real world project but applies them in short two hour exercises in which he designs and implements minimalistic software with little requirements. This could be a Minesweeper or a TicTacToe game for example. These training challenges should lead the developer to write better code and be more aware of code quality in real world projects.

RESEARCH,l page 22: spen 20 hours, 1000 loc, break habits, etc....

With these little training sessions, the Object Calisthenics help to create highly object oriented code  in small projects. When applying the rules, the developers automatically fulfill many important software patterns and principals leading to higher code quality than the code would have without the given rules. By training developers to focus the rules they automatically apply various helpful and important software principals and software patterns. 

Add: RESEARCH page 5: the excercise, strict!

However the idea is that the developers recoginzes the value of the resulting code and then applies parts of the rules or the principals behind them to larger, real world projects. 
Improving the quality of software's implementation by little training sessions - that is the basic idea. Jeff Bay, the author of the paper, included this idea also in the name of the rules. The word "Calisthenics" undistinctable describes the approach, the idea and the outcome of the exercise.

\section{Tool Support to Validate the Object Calisthenics}
The purpose of the Object Calisthenics was already described. However, in this paper the focus lies on the evaluation and prototypical implementation of tool support, validating the rules of the Object Calisthenics. 

The outcome of tool support validating the source code written during a Object Calisthenics session is the following. The tool support might shorten the time of the training and furthermore guarantees that the developer sticks to the given rules. 

- Now what is the outcome of tool support for the Object Calisthenics?

Therefore, the next chapter  \ref{Description} describes the rules Object Calisthenics to understand the software principals and quality metrics behind the Object Calisthenics. 
The ensuing chapter \ref{Evaluation} discusses tool support for every rule. 

\chapter{Object Calisthenics by Jeff Bay - Patterns and Principals}
\label{Description}
This chapter describes the patterns and principals behind the Object Calisthenics. 
- general introduction and introduciton o fpaper. Qualities, research stuff.

===RESEARCH===
poorly written code, procedural code

Desribe each very shortly: 

no reusabilaity

hard to maintain

overview

structure

no bundle o data and behaviour

no modularity

not understandable

maintainability is hard

OO saves us! --> But ... because

Comparision of procedural versus object oriented programming
procedural: step by step, seldom informaiton hiding, actions mainulate data. Actions are spread all ove rthe programming

oo: "bundle" with capabilities, hides structures, delegates tasks that are not done by the object itself to other objects, objects model real world behaviour, decoupled and separated in different modules. "what" leads to "how": encapsulation, abstraction, inheritance, polymorphism

advantages of oop: modules, reusable maintainable, simplicity (describe each shortly) 

Describe each quality, a bit more detailes, but also short and concise: 

cohesion

loose coupling

zero duplication

encapsulation

testability

readability

focus

\section{Advantages of Object Oriented Programming}

\section{The Rules and their Background}
This chapter describes the rules of the Object Calisthenics itself. 

Repeat form introduciton:
The exercise: strict coding standards etc... RESEARCH page 5

Every rule is described one after the other. For every rule there will be ??? infrmation??? . This is a short explanation, a good and a bad example. Furthermore every chapter describes the software patterns and software principals behind every rule. These are for example design patterns, software principals and best practices. The outcome of every rule is then summarized.

For every rule 1-9: 
 - Explain the rule. Use quotes of paper. (research)
 - Good example with explanation
 - Bad example with explanation
 - Describe idea and principal behind the pattern (research). Refer to other sources with large stuff to explain and refer to previous chapter if already explained...
 - Summarize the rule's purpose

\subsection{"Use One Level of Indentation per Method"}
asdf
\subsection{"Don’t Use the else Keyword"}
asdf
\subsection{"Wrap All Primitives andvlue."}
asdf
\subsection{"Use Only One Dot per Line"}
asdf
\subsection{"Don't Abbreviate"}
asdf
\subsection{"Keep All Entities Small"}
asdf
\subsection{"Don’t Use Any Classes with More Than Two Instance Variables"}
asdf
\subsection{"Use First-Class Collections"}
asdf
\subsection{"Don’t Use Any Getters/Setters/Properties"}
asdf
\section{Discussing the Rules}
\subsection{Similarities}
Categorize rules: Are there similarities from perspective of principle? ??? Together with next chapter?
\subsection{Precedence}
Own estimation: what's the most important rule? What do I think? What does the author think? Reason with descriptions and examples given
\subsection{Conclusion and Outcome}
Give an outcome of the rules. RESERACh page 21: 
behaviour and operation oriented
LoD and loose coupling
talk to friends
talk the protocol specified by the object's operation
Next page: conslucstion, no else ,naming, 
all in all: duplication of code and idea
==> "Simple and elegant Abstractions"



\chapter{Tool Support to Validate the Object Calisthenics - Evaluation}
\label{Evaluation}
\section{Tool Support and It's Advantage}
What is a tool? Why do tools help? What makes tools strong? Why do tools matter for developers?
Possible outcome of tool support for the OC's?
\section{Working Environment}
Describe ast generally. Say that Eclipse provides types representing the parts of code syntax. This is seen as given. 
Refer to other references.
Describe shortly how it is possible to do an AST validation with eclpise. Say that: "Eclipse" terms and standart terms are use. These are not further described in this paper. Give reference for questions about "parameter", "type", "class", "expression" or "statement".
Say that the validaiton in the next section is exactly implemented as described. One (???) example is shown in the Prototype chapter.
\section{Evaluation of Rule Validation}
Say that the priorization of the rules and the "ranking" is given in the end. This chapter is "rule specific", even if the next subsections refer to each other.

Foreach: 
 - Similarities found out in description may be similar in this validation?
 - Cathegorize the rules in groups form a validation perspecitve
 - Use examples given in description chapter to describe the typical structure of the rule. 
 - Explane "the positive case": What is the positive structure, satisfying the rule
 - What checks have to be done for a possible validation
 - Discussion of 'rule dependencies' within one rule (example: wrapper has to determine possible wrapper classes first...)
 - --> solution found/no solution found
 
 - Be self-critical: Now, were a solution is found (or not), describe the problems that occur with the described implementation

\subsection{"Use One Level of Indentation per Method"}
asdf
\subsection{"Don’t Use the else Keyword"}
asdf
\subsection{"Wrap All Primitives andvlue."}
asdf
\subsection{"Use Only One Dot per Line"}
asdf
\subsection{"Don't Abbreviate"}
asdf
\subsection{"Keep All Entities Small"}
asdf
\subsection{"Don’t Use Any Classes with More Than Two Instance Variables"}
asdf
\subsection{"Use First-Class Collections"}
asdf
\subsection{"Don’t Use Any Getters/Setters/Properties"}
asdf
\section{Result of the Evaluation}
Give a summary on how hard it was to implement the rules
\section{Future Work}

\chapter{Prototypical Implementation of Tool Support}
\section{Requirements}
Describe requirements for the prototype
\section{Architecture}
Describe overall architecture (???packages)
\section{Exemplary Rule Validation}
One example implementation of one rule validation
\section{Resulting Prototype}
Show screenshot and describe UI. What is possible, what is not possible. 
What are ideas that are still out there? 
How could the product improve?
\section{Outlook and Future Work}


%\textbf{}
%\begin{figure}[htb]
%\centering
%\includegraphics[width=0.8\textwidth]{FHWTLogo.jpg}
%\caption{Das Logo der FHWT}
%\label{fig:FHWTLogo}
%\end{figure}

